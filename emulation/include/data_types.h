
/*! \file 
* \brief Описание структур.
*
* Данные структуры предназначены для хранения параметров проекта, расчета,
* вывода, разностной сетки, материалов, позиции процесса в разбиении.
* \author Крюков А.А. anton.krv@gmail.com
*/

#ifndef _DATA_TYPES_HEADER_
#define _DATA_TYPES_HEADER_

#include <stdio.h>

/*!
* \brief Структура для хранения имени.
*/
typedef struct
{
    char data[64];/*!< хранимое имя. */
} _name64;
/*! создание имени для ссылки*/
typedef _name64 *name64;

/*!
* \brief Структура параметров запуска программы.
*/
typedef struct
{
    char prj_name[64];/*!< имя файла проекта. */
    char result_dir[256];/*!< путь для сохранения результатов. */
    char save_dir[256];/*!< путь для сохранения контрольной точки. */
    char auto_save_dir[256];/*!< путь для автосохранения. */
    int auto_save;/*!< через сколько шагов производить автосохранение. */
} _start;
/*! создание имени для ссылки*/
typedef _start *start;

/*!
* \brief Структура с данными вывода для массива.
*/
typedef struct
{
    int out_index;/*!< индекс выводимого массивов. */
    int out_sgs;/*!< тип вывода сгс/си. */
    int out_nx;/*!< число точке по x. */
    int out_ny;/*!< число точке по y. */
    int out_nz;/*!< число точке по z. */
    int* out_ix;/*!< номера точек вывода по x. */
    int* out_iy;/*!< номера точек вывода по y. */
    int* out_iz;/*!< номера точек вывода по z. */
} _output_arr;
/*! создание имени для ссылки*/
typedef _output_arr *output_arr;

/*!
* \brief Структура данных вывода.
*/
typedef struct
{
    int out_narr;/*!< число выводимых массивов. */
    int out_nt;/*!< число точек вывода по времени. */
    int *out_it;/*!< номера точек вывода по времени. */
    int cur_out_it;/*!< текущий номер точки вывода по времени. */
    output_arr out_arr;/*!< выводимые массивы. */
    int max_out_num_data;/*!< максимальный размер выводимого массива. */
} _output;
/*! создание имени для ссылки*/
typedef _output *output;

/*!
* \brief Структура для хранения данных проекта.
*/
typedef struct
{
    char grd_name[64];/*!< имя файла с сеткой. */
    char cel_name[64];/*!< имя файла с привязкой к модели. */
    char tok_name[64];/*!< имя файла с параметрами расчета. */
    char lay_name[64];/*!< имя файла со слоями. */
    char start_name[64];/*!< имя файла контрольной точки. */
    int n_output;/*!< число файлов выдачи. */
    name64 vid_names;/*!< имена файлов с описанием вывода. */
    name64 dat_names;/*!< имена файлов вывода. */
    output out_data;/*!< структуры с описанием вывода. */
    int nt_save;/*!< число точек сохранения. */
    int *it_save;/*!< точки сохранения. */
    int cur_it_save;/*!< текущий номер точки сохранения по времени. */
} _project;
/*! создание имени для ссылки*/
typedef _project *project;

typedef enum { BND_ZERO_E = 0,  //идеальный проводник
               BND_ZERO_H,      //идеальный магнтный проводник
               BND_MUR_2,       //условия мура второго порядка
               BND_CPML,        //CPML
               BND_INDEP        //независимо
             } boundaryType;//граничные условия

/*!
* \brief Структура для хранения данных расчета.
*/
typedef struct
{
    int l_shem;/*!< тип схемы. */
    int l_time;/*!< тип задачи. */
    boundaryType l_gran;/*!< тип граничных условий. */
    int l_tfsf;/*!< плоская волна в области. */
    int l_nfff;/*!< расчет диграммы направленности. */
    int l_disp;/*!< наличие дисперсионного материала. */
    int l_j;/*!< наличие сторонних токов. */
    int l_qc;/*!< наличие источника вторичных электронов. */
    int l_sec;/*!< наличие источника вторичной ионизации. */
    int l_eh_ext;/*!< наличие внешних полей. */
    int l_eh0;/*!< начальное поле. */
    int l_part;/*!< наличие частиц. */
    boundaryType xmin_bnd;/*!< тип граничных условий по x слева. */
    boundaryType xmax_bnd;/*!< тип граничных условий по x справа. */
    boundaryType ymin_bnd;/*!< тип граничных условий по y слева. */
    boundaryType ymax_bnd;/*!< тип граничных условий по y справа. */
    boundaryType zmin_bnd;/*!< тип граничных условий по z слева. */
    boundaryType zmax_bnd;/*!< тип граничных условий по z справа. */

    double front_x;/*!< x координата центра выделенного фронта. */
    double front_y;/*!< y координата центра выделенного фронта. */
    double front_z;/*!< z координата центра выделенного фронта. */
} _comp;
/*! создание имени для ссылки*/
typedef _comp *comp;

/*!
* \brief Структура для хранения данных сетки.
*/
typedef struct
{
    int nx;/*!< число разбиения по оси x. */
    int ny;/*!< число разбиения по оси y. */
    int nz;/*!< число разбиения по оси z. */
    int nt;/*!< число разбиения по времени. */
    double *xi;/*!< целая сетка по x. */
    double *xi05;/*!< полуцелая сетка по x. */
    double *dxi;/*!< целый шаг по x. */
    double *dxi05;/*!< полуцелый шаг по x. */
    double *yi;/*!< целая сетка по y. */
    double *yi05;/*!< полуцелая сетка по y. */
    double *dyi;/*!< целый шаг по y. */
    double *dyi05;/*!< полуцелый шаг по y. */
    double *zi;/*!< целая сетка по z. */
    double *zi05;/*!< полуцелая сетка по z. */
    double *dzi;/*!< целый шаг по z. */
    double *dzi05;/*!< полуцелый шаг по z. */
    double *ti;/*!< сетка по времени. */
} _grid;
/*! создание имени для ссылки*/
typedef _grid *grid;

/*!
* \brief Структура для хранения данных слоя.
*/
typedef struct
{
    int lay_num;    /*!< номер слоя. */

    double lay_eps; /*!< диэлектрическая проницаемость слоя [CГC]. */
    double lay_mu;  /*!< магнитная проницаемость слоя [CГC]. */
    double lay_sig; /*!< проводимость слоя [CГC]. */
} _layer;

/*!
* \brief Структура для хранения данных слоев.
*/
typedef struct
{
    int n_lay;/*!< число слоев. */
    _layer *data_lay;/*!< данные слоев. */
} _layers;
/*! создание имени для ссылки*/
typedef _layers *layers;

typedef enum { EX_ID = 0, EY_ID, EZ_ID, HX_ID, HY_ID, HZ_ID } fieldType;//индекс поля

#endif
